# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/dynamoid/all/dynamoid.rbi
#
# dynamoid-3.5.0

module Dynamoid
  def adapter; end
  def config; end
  def configure; end
  def included_models; end
  def logger; end
  extend Dynamoid
end
module Dynamoid::Errors
end
class Dynamoid::Errors::Error < StandardError
end
class Dynamoid::Errors::MissingRangeKey < Dynamoid::Errors::Error
end
class Dynamoid::Errors::MissingIndex < Dynamoid::Errors::Error
end
class Dynamoid::Errors::InvalidIndex < Dynamoid::Errors::Error
  def initialize(item); end
end
class Dynamoid::Errors::RecordNotDestroyed < Dynamoid::Errors::Error
  def initialize(record); end
  def record; end
end
class Dynamoid::Errors::ConditionalCheckFailedException < Dynamoid::Errors::Error
  def initialize(inner); end
  def inner_exception; end
end
class Dynamoid::Errors::RecordNotUnique < Dynamoid::Errors::ConditionalCheckFailedException
  def initialize(original_exception, record); end
  def original_exception; end
end
class Dynamoid::Errors::StaleObjectError < Dynamoid::Errors::ConditionalCheckFailedException
  def attempted_action; end
  def initialize(record, attempted_action); end
  def record; end
end
class Dynamoid::Errors::RecordNotFound < Dynamoid::Errors::Error
end
class Dynamoid::Errors::DocumentNotValid < Dynamoid::Errors::Error
  def document; end
  def initialize(document); end
end
class Dynamoid::Errors::InvalidQuery < Dynamoid::Errors::Error
end
class Dynamoid::Errors::UnsupportedKeyType < Dynamoid::Errors::Error
end
module Dynamoid::ApplicationTimeZone
  def self.at(value); end
  def self.utc_offset; end
end
module Dynamoid::DynamodbTimeZone
  def self.in_time_zone(value); end
end
module Dynamoid::Fields
  def [](name); end
  def []=(name, value); end
  def attributes; end
  def attributes=(arg0); end
  def attributes_before_type_cast; end
  def raw_attributes; end
  def read_attribute(name); end
  def read_attribute_before_type_cast(name); end
  def set_created_at; end
  def set_expires_field; end
  def set_inheritance_field; end
  def set_updated_at; end
  def write_attribute(name, value); end
  extend ActiveSupport::Concern
end
module Dynamoid::Fields::ClassMethods
  def field(name, type = nil, options = nil); end
  def generated_methods; end
  def range(name, type = nil, options = nil); end
  def remove_field(field); end
  def table(options); end
  def timestamps_enabled?; end
  def warn_about_method_overriding(method_name, field_name); end
end
module Dynamoid::Indexes
  extend ActiveSupport::Concern
end
module Dynamoid::Indexes::ClassMethods
  def find_index(hash, range = nil); end
  def global_secondary_index(options = nil); end
  def index_key(hash, range = nil); end
  def index_name(hash, range = nil); end
  def indexed_hash_keys; end
  def indexes; end
  def is_global_secondary_index?(hash, range = nil); end
  def is_local_secondary_index?(hash, range = nil); end
  def local_secondary_index(options = nil); end
end
class Dynamoid::Indexes::Index
  def __callbacks; end
  def __callbacks?; end
  def _run_validate_callbacks(&block); end
  def _validate_callbacks; end
  def _validators; end
  def _validators?; end
  def dynamoid_class; end
  def dynamoid_class=(arg0); end
  def hash_key; end
  def hash_key=(arg0); end
  def hash_key_schema; end
  def hash_key_schema=(arg0); end
  def initialize(attrs = nil); end
  def model_name(*args, &block); end
  def name; end
  def name=(arg0); end
  def projected_attributes; end
  def projected_attributes=(arg0); end
  def projection_type; end
  def range_key; end
  def range_key=(arg0); end
  def range_key_schema; end
  def range_key_schema=(arg0); end
  def read_capacity; end
  def read_capacity=(arg0); end
  def self.__callbacks; end
  def self.__callbacks=(val); end
  def self.__callbacks?; end
  def self._validate_callbacks; end
  def self._validate_callbacks=(value); end
  def self._validators; end
  def self._validators=(val); end
  def self._validators?; end
  def type; end
  def type=(arg0); end
  def validate_hash_key; end
  def validate_index_type; end
  def validate_projected_attributes; end
  def validate_range_key; end
  def validation_context; end
  def validation_context=(arg0); end
  def write_capacity; end
  def write_capacity=(arg0); end
  extend ActiveModel::Callbacks
  extend ActiveModel::Naming
  extend ActiveModel::Translation
  extend ActiveModel::Validations::ClassMethods
  extend ActiveModel::Validations::HelperMethods
  extend ActiveSupport::Callbacks::ClassMethods
  extend ActiveSupport::DescendantsTracker
  include ActiveModel::Validations
  include ActiveModel::Validations::HelperMethods
  include ActiveSupport::Callbacks
end
module Dynamoid::Associations
  extend ActiveSupport::Concern
end
module Dynamoid::Associations::Association
  def build(attributes = nil); end
  def declaration_field_name; end
  def declaration_field_type; end
  def find_target; end
  def initialize(source, name, options); end
  def loaded; end
  def loaded=(arg0); end
  def loaded?; end
  def name; end
  def name=(arg0); end
  def options; end
  def options=(arg0); end
  def reset; end
  def source; end
  def source=(arg0); end
  def source_attribute; end
  def source_class; end
  def source_ids; end
  def target; end
  def target_attribute; end
  def target_class; end
  def target_class_name; end
  def target_ids; end
end
module Dynamoid::Associations::SingleAssociation
  def ==(other); end
  def associate(hash_key); end
  def class(*args, &block); end
  def create!(attributes = nil); end
  def create(attributes = nil); end
  def delete; end
  def disassociate(_hash_key = nil); end
  def empty?; end
  def find_target; end
  def method_missing(method, *args); end
  def nil?; end
  def setter(object); end
  def target=(object); end
  include Dynamoid::Associations::Association
end
module Dynamoid::Associations::ManyAssociation
  def <<(object); end
  def ==(other); end
  def all; end
  def associate(hash_key); end
  def class(*args, &block); end
  def count(*args, &block); end
  def create!(attributes = nil); end
  def create(attributes = nil); end
  def delete(object); end
  def delete_all; end
  def destroy_all; end
  def disassociate(hash_key); end
  def each(&block); end
  def empty?(*args, &block); end
  def find_target; end
  def first(*args, &block); end
  def include?(object); end
  def initialize(*args); end
  def last(*args, &block); end
  def method_missing(method, *args); end
  def nil?(*args, &block); end
  def query; end
  def query=(arg0); end
  def records; end
  def results_with_query(results); end
  def setter(object); end
  def size(*args, &block); end
  def where(args); end
  include Dynamoid::Associations::Association
  include Enumerable
end
class Dynamoid::Associations::HasMany
  def target_association; end
  include Dynamoid::Associations::ManyAssociation
end
class Dynamoid::Associations::BelongsTo
  def associate(hash_key); end
  def declaration_field_name; end
  def declaration_field_type; end
  def target_association; end
  include Dynamoid::Associations::SingleAssociation
end
class Dynamoid::Associations::HasOne
  def target_association; end
  include Dynamoid::Associations::Association
  include Dynamoid::Associations::SingleAssociation
end
class Dynamoid::Associations::HasAndBelongsToMany
  def target_association; end
  include Dynamoid::Associations::ManyAssociation
end
module Dynamoid::Associations::ClassMethods
  def association(type, name, options = nil); end
  def belongs_to(name, options = nil); end
  def has_and_belongs_to_many(name, options = nil); end
  def has_many(name, options = nil); end
  def has_one(name, options = nil); end
end
module Dynamoid::Persistence
  def decrement!(attribute, by = nil); end
  def decrement(attribute, by = nil); end
  def delete; end
  def destroy!; end
  def destroy; end
  def increment!(attribute, by = nil); end
  def increment(attribute, by = nil); end
  def new_record; end
  def new_record=(arg0); end
  def new_record?; end
  def persisted?; end
  def save(options = nil); end
  def touch(name = nil); end
  def update!(conditions = nil); end
  def update(conditions = nil, &block); end
  def update_attribute(attribute, value); end
  def update_attributes!(attributes); end
  def update_attributes(attributes); end
  extend ActiveSupport::Concern
end
class Dynamoid::Persistence::Import
  def array_of_dumped_attributes(models); end
  def build_model(attributes); end
  def call; end
  def import(models); end
  def import_with_backoff(models); end
  def initialize(model_class, array_of_attributes); end
  def self.call(model_class, array_of_attributes); end
end
class Dynamoid::Persistence::UpdateFields
  def call; end
  def initialize(model_class, partition_key:, sort_key:, attributes:, conditions:); end
  def options_to_update_item; end
  def self.call(*args); end
  def undump_attributes(attributes); end
  def update_item; end
end
class Dynamoid::Persistence::Upsert
  def call; end
  def initialize(model_class, partition_key:, sort_key:, attributes:, conditions:); end
  def options_to_update_item; end
  def self.call(*args); end
  def undump_attributes(raw_attributes); end
  def update_item; end
end
class Dynamoid::Persistence::Save
  def call; end
  def conditions_for_write; end
  def initialize(model); end
  def self.call(model); end
end
module Dynamoid::Persistence::ClassMethods
  def create!(attrs = nil); end
  def create(attrs = nil); end
  def create_table(options = nil); end
  def delete_table; end
  def from_database(attrs = nil); end
  def import(array_of_attributes); end
  def inc(hash_key_value, range_key_value = nil, counters); end
  def table_name; end
  def update!(hash_key, range_key_value = nil, attrs); end
  def update(hash_key, range_key_value = nil, attrs); end
  def update_fields(hash_key_value, range_key_value = nil, attrs = nil, conditions = nil); end
  def upsert(hash_key_value, range_key_value = nil, attrs = nil, conditions = nil); end
end
module Dynamoid::Dumping
  def self.dump_attributes(attributes, attributes_options); end
  def self.dump_field(value, options); end
  def self.find_dumper(options); end
end
module Dynamoid::Dumping::DeepSanitizeHelper
  def deep_sanitize(value); end
  def invalid_value?(value); end
  def sanitize_array(array); end
  def sanitize_hash(hash); end
  extend Dynamoid::Dumping::DeepSanitizeHelper
end
class Dynamoid::Dumping::Base
  def initialize(options); end
  def process(value); end
end
class Dynamoid::Dumping::StringDumper < Dynamoid::Dumping::Base
end
class Dynamoid::Dumping::IntegerDumper < Dynamoid::Dumping::Base
end
class Dynamoid::Dumping::NumberDumper < Dynamoid::Dumping::Base
end
class Dynamoid::Dumping::SetDumper < Dynamoid::Dumping::Base
  def allowed_type?; end
  def element_options; end
  def element_type; end
  def process(set); end
  def process_typed_collection(set); end
end
class Dynamoid::Dumping::ArrayDumper < Dynamoid::Dumping::Base
  def allowed_type?; end
  def element_options; end
  def element_type; end
  def process(array); end
  def process_typed_collection(array); end
end
class Dynamoid::Dumping::MapDumper < Dynamoid::Dumping::Base
  def process(value); end
end
class Dynamoid::Dumping::DateTimeDumper < Dynamoid::Dumping::Base
  def format_datetime(value, options); end
  def process(value); end
end
class Dynamoid::Dumping::DateDumper < Dynamoid::Dumping::Base
  def format_date(value, options); end
  def process(value); end
end
class Dynamoid::Dumping::RawDumper < Dynamoid::Dumping::Base
  def process(value); end
end
class Dynamoid::Dumping::SerializedDumper < Dynamoid::Dumping::Base
  def process(value); end
end
class Dynamoid::Dumping::BooleanDumper < Dynamoid::Dumping::Base
  def process(value); end
end
class Dynamoid::Dumping::CustomTypeDumper < Dynamoid::Dumping::Base
  def process(value); end
end
module Dynamoid::Undumping
  def self.find_undumper(options); end
  def self.undump_attributes(attributes, attributes_options); end
  def self.undump_field(value, options); end
end
module Dynamoid::Undumping::UndumpHashHelper
  def undump_hash(hash); end
  def undump_hash_value(val); end
  extend Dynamoid::Undumping::UndumpHashHelper
end
class Dynamoid::Undumping::Base
  def initialize(options); end
  def process(value); end
end
class Dynamoid::Undumping::StringUndumper < Dynamoid::Undumping::Base
end
class Dynamoid::Undumping::IntegerUndumper < Dynamoid::Undumping::Base
  def process(value); end
end
class Dynamoid::Undumping::NumberUndumper < Dynamoid::Undumping::Base
end
class Dynamoid::Undumping::SetUndumper < Dynamoid::Undumping::Base
  def allowed_type?; end
  def element_options; end
  def element_type; end
  def process(set); end
  def process_typed_collection(set); end
end
class Dynamoid::Undumping::ArrayUndumper < Dynamoid::Undumping::Base
  def allowed_type?; end
  def element_options; end
  def element_type; end
  def process(array); end
  def process_typed_collection(array); end
end
class Dynamoid::Undumping::MapUndumper < Dynamoid::Undumping::Base
  def process(value); end
end
class Dynamoid::Undumping::DateTimeUndumper < Dynamoid::Undumping::Base
  def process(value); end
end
class Dynamoid::Undumping::DateUndumper < Dynamoid::Undumping::Base
  def process(value); end
end
class Dynamoid::Undumping::RawUndumper < Dynamoid::Undumping::Base
  def process(value); end
end
class Dynamoid::Undumping::SerializedUndumper < Dynamoid::Undumping::Base
  def process(value); end
end
class Dynamoid::Undumping::BooleanUndumper < Dynamoid::Undumping::Base
  def process(value); end
end
class Dynamoid::Undumping::CustomTypeUndumper < Dynamoid::Undumping::Base
  def process(value); end
end
module Dynamoid::TypeCasting
  def self.cast_attributes(attributes, attributes_options); end
  def self.cast_field(value, options); end
  def self.find_type_caster(options); end
end
class Dynamoid::TypeCasting::Base
  def initialize(options); end
  def process(value); end
end
class Dynamoid::TypeCasting::StringTypeCaster < Dynamoid::TypeCasting::Base
  def process(value); end
end
class Dynamoid::TypeCasting::IntegerTypeCaster < Dynamoid::TypeCasting::Base
  def process(value); end
end
class Dynamoid::TypeCasting::NumberTypeCaster < Dynamoid::TypeCasting::Base
  def process(value); end
end
class Dynamoid::TypeCasting::SetTypeCaster < Dynamoid::TypeCasting::Base
  def element_options; end
  def element_type; end
  def process(value); end
  def process_typed_set(set); end
  def type_cast_to_set(value); end
end
class Dynamoid::TypeCasting::ArrayTypeCaster < Dynamoid::TypeCasting::Base
  def element_options; end
  def element_type; end
  def process(value); end
  def process_typed_array(array); end
  def type_cast_to_array(value); end
end
class Dynamoid::TypeCasting::MapTypeCaster < Dynamoid::TypeCasting::Base
  def process(value); end
end
class Dynamoid::TypeCasting::DateTimeTypeCaster < Dynamoid::TypeCasting::Base
  def process(value); end
  def seconds_to_offset(seconds); end
  def string_utc_offset(string); end
end
class Dynamoid::TypeCasting::DateTypeCaster < Dynamoid::TypeCasting::Base
  def process(value); end
end
class Dynamoid::TypeCasting::RawTypeCaster < Dynamoid::TypeCasting::Base
end
class Dynamoid::TypeCasting::SerializedTypeCaster < Dynamoid::TypeCasting::Base
end
class Dynamoid::TypeCasting::BooleanTypeCaster < Dynamoid::TypeCasting::Base
  def process(value); end
end
class Dynamoid::TypeCasting::CustomTypeCaster < Dynamoid::TypeCasting::Base
end
class Dynamoid::PrimaryKeyTypeMapping
  def self.dynamodb_type(type, options); end
end
module Dynamoid::Dirty
  def attribute_change(attr); end
  def attribute_changed?(attr, options = nil); end
  def attribute_changed_by_setter?(attr_name); end
  def attribute_previous_change(attr); end
  def attribute_previously_changed?(attr); end
  def attribute_was(attr); end
  def attribute_will_change!(attr); end
  def attributes_changed_by_setter; end
  def changed; end
  def changed?; end
  def changed_attributes; end
  def changes; end
  def changes_applied; end
  def changes_include?(attr_name); end
  def clear_attribute_changes(attributes); end
  def clear_changes_information; end
  def previous_changes; end
  def previous_changes_include?(attr_name); end
  def reload(*arg0); end
  def restore_attribute!(attr); end
  def restore_attributes(attributes = nil); end
  def save!(*arg0); end
  def save(*arg0); end
  def set_attribute_was(attr, old_value); end
  def update!(*arg0); end
  def update(*arg0); end
  extend ActiveSupport::Concern
  include ActiveModel::AttributeMethods
end
module Dynamoid::Dirty::ClassMethods
  def from_database(*arg0); end
  def update_fields(*arg0); end
  def upsert(*arg0); end
end
module Dynamoid::Validations
  def save!; end
  def save(options = nil); end
  def valid?(context = nil); end
  extend ActiveSupport::Concern
  include ActiveModel::Validations
  include ActiveModel::Validations::Callbacks
end
module Dynamoid::Validations::ClassMethods
  def validates_presence_of(*attr_names); end
end
class Dynamoid::Validations::ClassMethods::PresenceValidator < ActiveModel::EachValidator
  def not_present?(value); end
  def validate_each(record, attr_name, value); end
end
module Dynamoid::Criteria
  extend ActiveSupport::Concern
end
class Dynamoid::Criteria::KeyFieldsDetector
  def find_keys_in_query; end
  def hash_key; end
  def index_name; end
  def initialize(query, source); end
  def key_present?; end
  def match_global_secondary_index; end
  def match_global_secondary_index_and_sort_key; end
  def match_local_secondary_index; end
  def match_table; end
  def match_table_and_sort_key; end
  def range_key; end
end
class Dynamoid::Criteria::KeyFieldsDetector::Query
  def contain?(field_name); end
  def contain_with_eq_operator?(field_name); end
  def initialize(query_hash); end
end
class Dynamoid::Criteria::IgnoredConditionsDetector
  def found?; end
  def ignored_conditions; end
  def ignored_keys; end
  def initialize(conditions); end
  def key_to_field(key); end
  def warning_message; end
end
class Dynamoid::Criteria::OverwrittenConditionsDetector
  def found?; end
  def ignored_conditions; end
  def initialize(conditions, conditions_new); end
  def key_to_field(key); end
  def overwritten_keys; end
  def warning_message; end
end
class Dynamoid::Criteria::NonexistentFieldsDetector
  def fields_existent; end
  def fields_from_conditions; end
  def found?; end
  def initialize(conditions, source); end
  def nonexistent_fields; end
  def warning_message; end
end
class Dynamoid::Criteria::Chain
  def all; end
  def batch(batch_size); end
  def consistent; end
  def consistent_opts; end
  def consistent_read; end
  def count; end
  def count_via_query; end
  def count_via_scan; end
  def delete_all; end
  def destroy_all; end
  def each(&block); end
  def field_hash(key); end
  def find_by_pages(&block); end
  def initialize(source); end
  def issue_scan_warning; end
  def items; end
  def key_fields_detector; end
  def last; end
  def pages; end
  def pluck(*args); end
  def project(*fields); end
  def query; end
  def query_opts; end
  def range_hash(key); end
  def range_query; end
  def raw_pages; end
  def raw_pages_via_query; end
  def raw_pages_via_scan; end
  def record_limit(limit); end
  def records; end
  def scan_index_forward(scan_index_forward); end
  def scan_limit(limit); end
  def scan_opts; end
  def scan_query; end
  def source; end
  def start(start); end
  def start_key; end
  def type_cast_condition_parameter(key, value); end
  def where(args); end
  include Enumerable
end
module Dynamoid::Criteria::ClassMethods
  def all(*args, &blk); end
  def batch(*args, &blk); end
  def each(*args, &blk); end
  def find_by_pages(*args, &blk); end
  def first(*args, &blk); end
  def last(*args, &blk); end
  def pluck(*args, &blk); end
  def project(*args, &blk); end
  def record_limit(*args, &blk); end
  def scan_index_forward(*args, &blk); end
  def scan_limit(*args, &blk); end
  def start(*args, &blk); end
  def where(*args, &blk); end
end
module Dynamoid::Finders
  extend ActiveSupport::Concern
end
module Dynamoid::Finders::ClassMethods
  def _find_all(ids, options = nil); end
  def _find_by_id(id, options = nil); end
  def find(*ids, **options); end
  def find_all(ids, options = nil); end
  def find_all_by_composite_key(hash_key, options = nil); end
  def find_all_by_secondary_index(hash, options = nil); end
  def find_by_composite_key(hash_key, range_key, options = nil); end
  def find_by_id(id, options = nil); end
  def method_missing(method, *args); end
end
module Dynamoid::IdentityMap
  def delete; end
  def identity_map; end
  def identity_map_key; end
  def save(*args); end
  def self.clear; end
  extend ActiveSupport::Concern
end
module Dynamoid::IdentityMap::ClassMethods
  def find_by_id(id, options = nil); end
  def from_database(attrs = nil); end
  def identity_map; end
  def identity_map_key(attrs); end
  def identity_map_off?; end
  def identity_map_on?; end
end
module Dynamoid::Config
  def access_key; end
  def access_key=(value); end
  def access_key?; end
  def adapter; end
  def adapter=(value); end
  def adapter?; end
  def application_timezone; end
  def application_timezone=(value); end
  def application_timezone?; end
  def backoff; end
  def backoff=(value); end
  def backoff?; end
  def backoff_strategies; end
  def backoff_strategies=(value); end
  def backoff_strategies?; end
  def batch_size; end
  def batch_size=(value); end
  def batch_size?; end
  def build_backoff; end
  def capacity_mode; end
  def capacity_mode=(value); end
  def capacity_mode?; end
  def convert_big_decimal; end
  def convert_big_decimal=(value); end
  def convert_big_decimal?; end
  def credentials; end
  def credentials=(value); end
  def credentials?; end
  def default_logger; end
  def dynamodb_timezone; end
  def dynamodb_timezone=(value); end
  def dynamodb_timezone?; end
  def endpoint; end
  def endpoint=(value); end
  def endpoint?; end
  def http_continue_timeout; end
  def http_continue_timeout=(value); end
  def http_continue_timeout?; end
  def http_idle_timeout; end
  def http_idle_timeout=(value); end
  def http_idle_timeout?; end
  def http_open_timeout; end
  def http_open_timeout=(value); end
  def http_open_timeout?; end
  def http_read_timeout; end
  def http_read_timeout=(value); end
  def http_read_timeout?; end
  def identity_map; end
  def identity_map=(value); end
  def identity_map?; end
  def logger; end
  def logger=(logger); end
  def models_dir; end
  def models_dir=(value); end
  def models_dir?; end
  def namespace; end
  def namespace=(value); end
  def namespace?; end
  def read_capacity; end
  def read_capacity=(value); end
  def read_capacity?; end
  def region; end
  def region=(value); end
  def region?; end
  def reset_access_key; end
  def reset_adapter; end
  def reset_application_timezone; end
  def reset_backoff; end
  def reset_backoff_strategies; end
  def reset_batch_size; end
  def reset_capacity_mode; end
  def reset_convert_big_decimal; end
  def reset_credentials; end
  def reset_dynamodb_timezone; end
  def reset_endpoint; end
  def reset_http_continue_timeout; end
  def reset_http_idle_timeout; end
  def reset_http_open_timeout; end
  def reset_http_read_timeout; end
  def reset_identity_map; end
  def reset_models_dir; end
  def reset_namespace; end
  def reset_read_capacity; end
  def reset_region; end
  def reset_secret_key; end
  def reset_store_attribute_with_nil_value; end
  def reset_store_boolean_as_native; end
  def reset_store_date_as_string; end
  def reset_store_datetime_as_string; end
  def reset_sync_retry_max_times; end
  def reset_sync_retry_wait_seconds; end
  def reset_timestamps; end
  def reset_warn_on_scan; end
  def reset_write_capacity; end
  def secret_key; end
  def secret_key=(value); end
  def secret_key?; end
  def store_attribute_with_nil_value; end
  def store_attribute_with_nil_value=(value); end
  def store_attribute_with_nil_value?; end
  def store_boolean_as_native; end
  def store_boolean_as_native=(value); end
  def store_boolean_as_native?; end
  def store_date_as_string; end
  def store_date_as_string=(value); end
  def store_date_as_string?; end
  def store_datetime_as_string; end
  def store_datetime_as_string=(value); end
  def store_datetime_as_string?; end
  def sync_retry_max_times; end
  def sync_retry_max_times=(value); end
  def sync_retry_max_times?; end
  def sync_retry_wait_seconds; end
  def sync_retry_wait_seconds=(value); end
  def sync_retry_wait_seconds?; end
  def timestamps; end
  def timestamps=(value); end
  def timestamps?; end
  def warn_on_scan; end
  def warn_on_scan=(value); end
  def warn_on_scan?; end
  def write_capacity; end
  def write_capacity=(value); end
  def write_capacity?; end
  extend Dynamoid::Config
  extend Dynamoid::Config::Options
end
module Dynamoid::Config::Options
  def defaults; end
  def option(name, options = nil); end
  def reset; end
  def settings; end
end
module Dynamoid::Config::BackoffStrategies
end
class Dynamoid::Config::BackoffStrategies::ConstantBackoff
  def self.call(sec = nil); end
end
class Dynamoid::Config::BackoffStrategies::ExponentialBackoff
  def self.call(opts = nil); end
end
module Dynamoid::Loadable
  def load(attrs); end
  def reload; end
  extend ActiveSupport::Concern
end
module Dynamoid::Components
  extend ActiveSupport::Concern
  include ActiveModel::AttributeMethods
  include ActiveModel::Conversion
  include ActiveModel::Naming
  include ActiveModel::Serializers::JSON
  include Dynamoid::Associations
  include Dynamoid::Criteria
  include Dynamoid::Dirty
  include Dynamoid::Fields
  include Dynamoid::Finders
  include Dynamoid::IdentityMap
  include Dynamoid::Indexes
  include Dynamoid::Loadable
  include Dynamoid::Persistence
  include Dynamoid::Validations
end
module Dynamoid::Document
  def ==(other); end
  def dumped_range_value; end
  def eql?(other); end
  def evaluate_default_value(val); end
  def hash; end
  def hash_key; end
  def hash_key=(value); end
  def initialize(attrs = nil); end
  def range_value; end
  def range_value=(value); end
  extend ActiveSupport::Concern
  include Dynamoid::Components
end
module Dynamoid::Document::ClassMethods
  def attr_readonly(*read_only_attributes); end
  def build(attrs = nil); end
  def capacity_mode; end
  def choose_right_class(attrs); end
  def count; end
  def deep_subclasses; end
  def exists?(id_or_conditions = nil); end
  def hash_key; end
  def inheritance_field; end
  def read_capacity; end
  def table(options = nil); end
  def write_capacity; end
end
module Dynamoid::AdapterPlugin
end
class Dynamoid::AdapterPlugin::AwsSdkV3
  def batch_delete_item(options); end
  def batch_get_item(table_names_with_ids, options = nil, &block); end
  def batch_write_item(table_name, objects, options = nil); end
  def client; end
  def connect!; end
  def connection_config; end
  def count(table_name); end
  def create_table(table_name, key = nil, options = nil); end
  def create_table_synchronously(table_name, key = nil, options = nil); end
  def delete_item(table_name, key, options = nil); end
  def delete_table(table_name, options = nil); end
  def delete_table_synchronously(table_name, options = nil); end
  def describe_table(table_name, reload = nil); end
  def expected_stanza(conditions = nil); end
  def get_item(table_name, key, options = nil); end
  def key_stanza(table, hash_key, range_key = nil); end
  def list_tables; end
  def put_item(table_name, object, options = nil); end
  def query(table_name, options = nil); end
  def query_count(table_name, options = nil); end
  def result_item_to_hash(item); end
  def sanitize_item(attributes); end
  def scan(table_name, conditions = nil, options = nil); end
  def scan_count(table_name, conditions = nil, options = nil); end
  def self.attribute_value_list(operator, value); end
  def table_cache; end
  def truncate(table_name); end
  def update_item(table_name, key, options = nil); end
  def update_time_to_live(table_name:, attribute:); end
end
module Dynamoid::AdapterPlugin::AwsSdkV3::Middleware
end
class Dynamoid::AdapterPlugin::AwsSdkV3::Middleware::Backoff
  def call(request); end
  def initialize(next_chain); end
end
class Dynamoid::AdapterPlugin::AwsSdkV3::Middleware::Limit
  def call(request); end
  def initialize(next_chain, record_limit: nil, scan_limit: nil); end
end
class Dynamoid::AdapterPlugin::AwsSdkV3::Middleware::StartKey
  def call(request); end
  def initialize(next_chain); end
end
class Dynamoid::AdapterPlugin::AwsSdkV3::Query
  def attributes_to_get; end
  def build_request; end
  def call; end
  def client; end
  def conditions; end
  def hash_key_name; end
  def initialize(client, table, opts = nil); end
  def key_conditions; end
  def options; end
  def query_filter; end
  def range_key_name; end
  def record_limit; end
  def scan_limit; end
  def table; end
end
class Dynamoid::AdapterPlugin::AwsSdkV3::Scan
  def attributes_to_get; end
  def build_request; end
  def call; end
  def client; end
  def conditions; end
  def initialize(client, table, conditions = nil, options = nil); end
  def options; end
  def record_limit; end
  def scan_filter; end
  def scan_limit; end
  def table; end
end
class Dynamoid::AdapterPlugin::AwsSdkV3::UntilPastTableStatus
  def call; end
  def check_table_status?(counter, resp, expect_status); end
  def client; end
  def initialize(client, table_name, status = nil); end
  def status; end
  def table_name; end
end
class Dynamoid::AdapterPlugin::AwsSdkV3::CreateTable
  def api_type(type); end
  def attribute_definition_element(name, dynamoid_type); end
  def aws_key_schema(hash_key_schema, range_key_schema); end
  def build_all_attribute_definitions(key_schema, secondary_indexes = nil); end
  def build_attribute_definitions(hash_key_schema, range_key_schema = nil); end
  def call; end
  def client; end
  def index_to_aws_hash(index); end
  def initialize(client, table_name, key, options); end
  def key; end
  def options; end
  def table_name; end
end
class Dynamoid::AdapterPlugin::AwsSdkV3::BatchGetItem
  def build_request(table, ids); end
  def call; end
  def client; end
  def initialize(client, tables_with_ids, options = nil); end
  def options; end
  def tables_with_ids; end
end
class Dynamoid::AdapterPlugin::AwsSdkV3::BatchGetItem::Response
  def initialize(api_response); end
  def item_to_hash(item); end
  def items_grouped_by_table; end
  def successful_partially?; end
  def unprocessed_ids(table); end
end
class Dynamoid::AdapterPlugin::AwsSdkV3::ItemUpdater
  def add(values); end
  def delete(values); end
  def initialize(table, key, range_key = nil); end
  def key; end
  def range_key; end
  def sanitize_attributes(attributes); end
  def set(values); end
  def table; end
  def to_h; end
end
class Dynamoid::AdapterPlugin::AwsSdkV3::Table
  def col_type(col); end
  def hash_key; end
  def initialize(schema); end
  def item_count; end
  def name; end
  def range_key; end
  def range_type; end
  def schema; end
end
class Dynamoid::Adapter
  def adapter; end
  def batch_delete_item(*args, &blk); end
  def batch_get_item(*args, &blk); end
  def batch_write_item(*args, &blk); end
  def benchmark(method, *args); end
  def clear_cache!; end
  def create_table(table_name, key, options = nil); end
  def delete(table, ids, options = nil); end
  def delete_item(*args, &blk); end
  def delete_table(table_name, options = nil); end
  def get_item(*args, &blk); end
  def initialize; end
  def list_tables(*args, &blk); end
  def method_missing(method, *args, &block); end
  def put_item(*args, &blk); end
  def query(table_name, opts = nil); end
  def read(table, ids, options = nil, &blk); end
  def scan(table, query = nil, opts = nil); end
  def self.adapter_plugin_class; end
  def tables; end
  def truncate(*args, &blk); end
  def write(table, object, options = nil); end
end
module Dynamoid::Tasks
end
module Dynamoid::Tasks::Database
  def create_tables; end
  def ping; end
  def self.create_tables; end
  def self.ping; end
end
module Dynamoid::Middleware
end
class Dynamoid::Middleware::IdentityMap
  def call(env); end
  def initialize(app); end
end
class Dynamoid::Railtie < Rails::Railtie
end
